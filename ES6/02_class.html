<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS class keyword</title>
    <script>

        // 2. 객체(변수+함수)를 생성하는새로운방법 : class 키워드 등장

        // 3. 기존 방식 [리터럴객체, 생성자함수]
        let p={
            name: 'sam',
            age: 20,
            show:function(){
                document.write(this.name+ " : " + this.age + "<br><br>");
            }
        }
        p.show();

        // 만들어질 객체의 설계도
        function Board(title, message, date){
            // 멤버변수 : property(속성)
            this.title=title;
            this.message= message;
            this.date=date;

            // 멤버함수 : method(메소드)
            this.show= function(){
                document.write(this.title+"<br>");
                document.write(this.message+"<br>");
                document.write(this.date+"<br>");
                document.write("<br>");
            }
        }
        const b1= new Board('Hello', 'Nice to meet you', '2026.01.14');
        const b2= new Board('Second', 'Have a good day', '2026.01.15');

        b1.show();
        b2.show();
        //----------------------------------------------------------------------

        // 생성자 함수를 이용한 설계도 제작방식이 일반함수와 잘 구별되지 않는다.
        // 객체 설계도를 만드는 전용 키워드: class

        // 클래스 선언(설계도 작성)
        class Person{
            // 멤버변수
            // this.name;  // error
            //아무 키워드 없이 변수명만 사용
            name="sam";
            age=20;
            address;

            // 객체를 생성(new)할때 자동으로 실행되는 아주 특별한 함수 : '생성자 함수'라고 부름
            // 함수이름이 정해져 있음.
            constructor(name, age, address, tel){
                document.write('여기는 객체를 생성하면 자동으로 실행되요.<br>');
                // 매개변수로 받은 값들을 멤버변수에 대입해 주기
                this.name= name;
                this.age= age;
                this.address= address;
                // 멤버변수로 선언되지 않은 멤버변수를 사용하면 이때 자동으로 멤버로 선언 됨.
                this.tel= tel;
            }

            // 멤버함수
            // function show(){} // error 나옴
            // 키워드 없이 그냥 함수이름만...
            show(){
                document.write(this.name + "  : " + this.age + " - " + this.address + "<br>");
            }
            // 같은 이름의 멤버가 또 있으면.. 덮어쓰기로 된다 (오버로딩이 아님)
            show(){
                document.write('person show!!<br>');
            }
        }
        // 설계도를 이용하여 객체를 생성
        const person= new Person();
        person.name="robin";
        person.age=25;
        person.address='seoul';
        person.show();

        const person2= new Person('kim', 20, 'busan');
        person2.show(100);

        // 설계도에 없던 멤버를 특정 객체에 추가하는 것도 가능함;
        person.hobby="swimming";
        document.write(person.hobby + "<br>");

        // hobby와 같은 없는 멤버를 추가할 수는 있지만 값을 출력할 수는 없음.
        document.write(person.gender + "<br>"); //undefined.. 이건 추가는 아님.

        document.write(person2.hobby + "<br>");

        person.output= function(){
            this.show();
            document.write(this.hobby + "<br>");
        }
        person.output();
        // person2.output();

        document.write('<hr>');

        // 기존의 클래스를 물려 받아 확장하여 새로운 클래스를 설계하는 기법 : 상속

        // 클래스 상속

        // 상속해 줄 부모클래스 
        class Human{
            constructor(name, age){
                this.name= name;
                this.age= age;            
            }
            show(){
                document.write(this.name+" : " + this.age);                
            }
        }
        const h= new Human('sam', 20);
        h.show();
         document.write('<br>');

        // 상속받을 자식 클래스 [이름, 나이, 전공]
        class Student extends Human{
            constructor(name, age, major){
                // this.name=name;    멤버값
                // this.age= age;
                // 부모(Human)의 생성자를 호출하면서 값들을 전달해주면 대신 멤버에 대입해 줌
                super(name, age);
                this.major= major;
            }

        // 상속받은 기능함수 show()는 [이름, 나이]만 출력함
        // 그래서 기존 show()함수을 개선하기 : override
        show() {
            super.show(); // 이름, 나이는 부모
            document.write(this.major + "<br>");
        }
    }
    const s= new Student('park', '30', 'web');
    s.show();  // 오버라이드 안 show()가 발동됨

    class AlbaStudent extends Student{
        // 아무것도 안 써도 이미.. Student 클래스의 멤버를 모두 보여한 상태.
    }

        const alba=new AlbaStudent();
        alba.show();

        document.write('<hr>');

        // 정적 static 멤버 - 객체를 생성하지 않아도 사용가능한 멤버들.
        // 클래스 메소드, 변수 라고도 부름
        class First{
            static show(){
                document.write('First show....<br>');
            }

            // 일반 메소드 - 객체를 생성해야만 사용가능한 멤버들.
            output(){

            }
             
            static title="First 클래스야";
        }
        // 객체 생성(new)없이 클래스명.메소드명 으로 사용
        First.show();

        document.write(First.title+"<br>");

        // 정적 멤버는 객체마다 있는게 아니라.. 클래스에 소속된 멤버임. 그래서
        // 객체 생성하여 사용하면 에러!
        const ff=new First();
        //ff.show(); // error

        const d=new Date();
        d.getFullYear();

        Math.floor(3.14);

        document.write('<hr>');

        // 구조 분해 할당(비구조화 할당 이라고도 부름)  -- 리액트 개발자들이 선호함.
        class Nice{
            name="kim";
            age=20;
            address="paris";
        }

        let nice= new Nice();
        document.write(nice.name +"<br>");
        document.write(nice.age +"<br>");
        document.write(nice.address + "<br>");

        // 이 중에서 age 변수값을 여러군데 에서 사용해야 한다면...
        // 매번 객체명 쓰는 것이 불편함.
        // 그럴때 일반 변수에 대입하여 사용함.
        // let age=nice.age;
        // let name=nice.name;

        let {name, age}= nice;  // 객체의 구조를 분해하여 원하는 멤버만 쭉 뽑아오는 문법
        
        document.write(age+"<br>");
        document.write(name+"<br>");

        // 이 구조분해 할당은 어떤 함수에 객체가 전달 되었을때 많이 애용함.
        
        const n1=new Nice();
        n1.address='seoul';

        const n2=new Nice();
        n2.address="busan";

        const n3=new Nice();
        n3.address="paris";
        
        // Nice 클래스로 만든 객체를 전달받아 주소 속성값을 출력하는 기능 함수 설계
        // function showNiceAdderss( nice ){
        // document.write("<h3>");
        // document.write(nice.address);
        // document.write("</h3>");
        // }

        function showNiceAdderss( {address} ){  // 구조분해 할당
            document.write("<h3>");
            document.write(address);
            document.write("</h3>");
        }

        showNiceAdderss(n1);
        showNiceAdderss(n2);
        showNiceAdderss(n3);


        
    </script>
</head>
<body>
    
</body>
</html>